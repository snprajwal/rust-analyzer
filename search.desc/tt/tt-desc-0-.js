searchState.loadedDescShard("tt", 0, "<code>tt</code> crate defines a <code>TokenTree</code> data structure: this is the …\nThe token cannot join with the following token to form a …\nIdentifier or keyword.\nThe token can join with the following token to form a …\nThe token can join with the following token to form a …\nIndicates whether a token can join with the following …\nA range in text, represented as a pair of <code>TextSize</code>.\nA measure of text length. Also, equivalently, an index …\nCreate a new <code>TextRange</code> with the given <code>offset</code> and <code>len</code> (…\nStateful iteration over token trees.\nBuilds, and remove the top subtree if it has only one …\nAdd an offset to this range.\nChecked addition. Returns <code>None</code> if overflow occurred.\nSubtract an offset from this range.\nChecked subtraction. Returns <code>None</code> if overflow occurred.\nCheck if this range contains an offset.\nCheck if this range contains an offset.\nCheck if this range completely contains another range.\nCount the number of tokens recursively\nExtends the range to cover <code>other</code> as well.\nExtends the range to cover <code>other</code> offsets as well.\nCreate a zero-length range at the specified offset (…\nThe end point of this range.\nThis does not check the token trees are valid, beware!\nThis returns a <strong>flat</strong> structure of tokens (subtrees will be …\nConverts unclosed subtree to a punct of their open …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe range covered by both ranges, if it exists. If the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this range is empty.\nA “Parser” structure for token trees. We use this when …\nThe size of this range.\nNumber of following token trees that belong to this …\nCreates a new <code>TextRange</code> with the given <code>start</code> and <code>end</code> (…\nCreates a new instance of <code>TextSize</code> from a raw <code>u32</code>.\nThe text size of some primitive text-like object.\nRelative order of the two ranges (overlapping ranges are …\nYou cannot call this consecutively, it will only work once …\nThe start point of this range.\nA simple line string used for debugging\nCreate a range up to the given end (<code>..end</code>).\nBump the cursor, and enters a subtree if it is on one.\nCheck whether it is eof\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the <code>TokenTree</code> at the cursor if it is not at the …\nReturns consecutive <code>Punct</code>s that can be glued together.\n<strong>Warning</strong>: This advances <code>skip</code> <strong>flat</strong> token trees, subtrees …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>peek().is_none()</code>, but a bit faster.")