<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Term search"><title>term_search in hir::term_search - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="hir" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../hir/index.html">hir</a><span class="version">0.0.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">term_<wbr>search</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#term-search" title="Term search">Term search</a></li><li><a href="#arguments" title="Arguments">Arguments</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In hir::<wbr>term_<wbr>search</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">hir</a>::<wbr><a href="index.html">term_search</a></span><h1>Function <span class="fn">term_search</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/hir/term_search.rs.html#266-303">Source</a> </span></div><pre class="rust item-decl"><code>pub fn term_search&lt;DB: <a class="trait" href="../db/trait.HirDatabase.html" title="trait hir::db::HirDatabase">HirDatabase</a>&gt;(ctx: &amp;<a class="struct" href="struct.TermSearchCtx.html" title="struct hir::term_search::TermSearchCtx">TermSearchCtx</a>&lt;'_, DB&gt;) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="enum.Expr.html" title="enum hir::term_search::Expr">Expr</a>&gt;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="term-search"><a class="doc-anchor" href="#term-search">ยง</a>Term search</h2>
<p>Search for terms (expressions) that unify with the <code>goal</code> type.</p>
<h2 id="arguments"><a class="doc-anchor" href="#arguments">ยง</a>Arguments</h2>
<ul>
<li><code>ctx</code> - Context for term search</li>
</ul>
<p>Internally this function uses Breadth First Search to find path to <code>goal</code> type.
The general idea is following:</p>
<ol>
<li>Populate lookup (frontier for BFS) from values (local variables, statics, constants, etc)
as well as from well knows values (such as <code>true/false</code> and <code>()</code>)</li>
<li>Iteratively expand the frontier (or contents of the lookup) by trying different type
transformation tactics. For example functions take as from set of types (arguments) to some
type (return type). Other transformations include methods on type, type constructors and
projections to struct fields (field access).</li>
<li>If we run out of fuel (term search takes too long) we stop iterating.</li>
<li>Return all the paths (type trees) that take us to the <code>goal</code> type.</li>
</ol>
<p>Note that there are usually more ways we can get to the <code>goal</code> type but some are discarded to
reduce the memory consumption. It is also unlikely anyone is willing ti browse through
thousands of possible responses so we currently take first 10 from every tactic.</p>
</div></details></section></div></main></body></html>